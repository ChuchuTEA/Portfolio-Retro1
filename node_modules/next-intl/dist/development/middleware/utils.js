'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('../shared/utils.js');

function getFirstPathnameSegment(pathname) {
  return pathname.split('/')[1];
}
function getInternalTemplate(pathnames, pathname, locale) {
  // Try to find a localized pathname that matches
  for (const [internalPathname, localizedPathnamesOrPathname] of Object.entries(pathnames)) {
    if (typeof localizedPathnamesOrPathname === 'string') {
      const localizedPathname = localizedPathnamesOrPathname;
      if (utils.matchesPathname(localizedPathname, pathname)) {
        return [undefined, internalPathname];
      }
    } else {
      // Prefer the entry with the current locale in case multiple
      // localized pathnames match the current pathname
      const sortedEntries = Object.entries(localizedPathnamesOrPathname);
      const curLocaleIndex = sortedEntries.findIndex(_ref => {
        let [entryLocale] = _ref;
        return entryLocale === locale;
      });
      if (curLocaleIndex > 0) {
        sortedEntries.unshift(sortedEntries.splice(curLocaleIndex, 1)[0]);
      }
      for (const [entryLocale, entryPathname] of sortedEntries) {
        if (utils.matchesPathname(entryPathname, pathname)) {
          return [entryLocale, internalPathname];
        }
      }
    }
  }

  // Try to find an internal pathname that matches (this can be the case
  // if all localized pathnames are different from the internal pathnames).
  for (const internalPathname of Object.keys(pathnames)) {
    if (utils.matchesPathname(internalPathname, pathname)) {
      return [undefined, internalPathname];
    }
  }

  // No match
  return [undefined, undefined];
}
function formatTemplatePathname(sourcePathname, sourceTemplate, targetTemplate, localePrefix) {
  const params = getRouteParams(sourceTemplate, sourcePathname);
  let targetPathname = '';
  if (localePrefix) {
    targetPathname = "/".concat(localePrefix);
  }
  targetPathname += formatPathname(targetTemplate, params);
  targetPathname = normalizeTrailingSlash(targetPathname);
  return targetPathname;
}

/**
 * Removes potential locales from the pathname.
 */
function getNormalizedPathname(pathname, locales) {
  // Add trailing slash for consistent handling
  // both for the root as well as nested paths
  if (!pathname.endsWith('/')) {
    pathname += '/';
  }
  const match = pathname.match(new RegExp("^/(".concat(locales.join('|'), ")/(.*)"), 'i'));
  let result = match ? '/' + match[2] : pathname;
  if (result !== '/') {
    result = normalizeTrailingSlash(result);
  }
  return result;
}
function findCaseInsensitiveLocale(candidate, locales) {
  return locales.find(locale => locale.toLowerCase() === candidate.toLowerCase());
}
function getPathnameLocale(pathname, locales) {
  const pathLocaleCandidate = getFirstPathnameSegment(pathname);
  const pathLocale = findCaseInsensitiveLocale(pathLocaleCandidate, locales) ? pathLocaleCandidate : undefined;
  return pathLocale;
}
function getRouteParams(template, pathname) {
  const regex = utils.templateToRegex(template);
  const match = regex.exec(pathname);
  if (!match) return undefined;
  const params = {};
  for (let i = 1; i < match.length; i++) {
    var _template$match;
    const key = (_template$match = template.match(/\[([^\]]+)\]/g)) === null || _template$match === void 0 ? void 0 : _template$match[i - 1].replace(/[[\]]/g, '');
    if (key) params[key] = match[i];
  }
  return params;
}
function formatPathname(template, params) {
  if (!params) return template;

  // Simplify syntax for optional catchall ('[[...slug]]') so
  // we can replace the value with simple interpolation
  template = template.replace(/\[\[/g, '[').replace(/\]\]/g, ']');
  let result = template;
  Object.entries(params).forEach(_ref2 => {
    let [key, value] = _ref2;
    result = result.replace("[".concat(key, "]"), value);
  });
  return result;
}
function getPathWithSearch(pathname, search) {
  let pathWithSearch = pathname;
  if (search) {
    pathWithSearch += search;
  }
  return pathWithSearch;
}
function getHost(requestHeaders) {
  var _ref3, _requestHeaders$get;
  return (_ref3 = (_requestHeaders$get = requestHeaders.get('x-forwarded-host')) !== null && _requestHeaders$get !== void 0 ? _requestHeaders$get : requestHeaders.get('host')) !== null && _ref3 !== void 0 ? _ref3 : undefined;
}
function isLocaleSupportedOnDomain(locale, domain) {
  return domain.defaultLocale === locale || !domain.locales || domain.locales.includes(locale);
}
function getBestMatchingDomain(curHostDomain, locale, domainConfigs) {
  let domainConfig;

  // Prio 1: Stay on current domain
  if (curHostDomain && isLocaleSupportedOnDomain(locale, curHostDomain)) {
    domainConfig = curHostDomain;
  }

  // Prio 2: Use alternative domain with matching default locale
  if (!domainConfig) {
    domainConfig = domainConfigs.find(cur => cur.defaultLocale === locale);
  }

  // Prio 3: Use alternative domain with restricted matching locale
  if (!domainConfig) {
    domainConfig = domainConfigs.find(cur => cur.locales != null && cur.locales.includes(locale));
  }

  // Prio 4: Stay on the current domain if it supports all locales
  if (!domainConfig && (curHostDomain === null || curHostDomain === void 0 ? void 0 : curHostDomain.locales) == null) {
    domainConfig = curHostDomain;
  }

  // Prio 5: Use alternative domain that supports all locales
  if (!domainConfig) {
    domainConfig = domainConfigs.find(cur => !cur.locales);
  }
  return domainConfig;
}
function applyBasePath(pathname, basePath) {
  return normalizeTrailingSlash(basePath + pathname);
}
function normalizeTrailingSlash(pathname) {
  if (pathname.endsWith('/')) {
    pathname = pathname.slice(0, -1);
  }
  return pathname;
}

exports.applyBasePath = applyBasePath;
exports.findCaseInsensitiveLocale = findCaseInsensitiveLocale;
exports.formatPathname = formatPathname;
exports.formatTemplatePathname = formatTemplatePathname;
exports.getBestMatchingDomain = getBestMatchingDomain;
exports.getFirstPathnameSegment = getFirstPathnameSegment;
exports.getHost = getHost;
exports.getInternalTemplate = getInternalTemplate;
exports.getNormalizedPathname = getNormalizedPathname;
exports.getPathWithSearch = getPathWithSearch;
exports.getPathnameLocale = getPathnameLocale;
exports.getRouteParams = getRouteParams;
exports.isLocaleSupportedOnDomain = isLocaleSupportedOnDomain;
