'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('../../shared/utils.js');

// Minor false positive: A route that has both optional and
// required params will allow optional params.
function normalizeNameOrNameWithParams(href) {
  // @ts-expect-error -- `extends string` in the generic unfortunately weakens the type
  return typeof href === 'string' ? {
    pathname: href
  } : href;
}
function serializeSearchParams(searchParams) {
  function serializeValue(value) {
    return String(value);
  }
  const urlSearchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(searchParams)) {
    if (Array.isArray(value)) {
      value.forEach(cur => {
        urlSearchParams.append(key, serializeValue(cur));
      });
    } else {
      urlSearchParams.set(key, serializeValue(value));
    }
  }
  return '?' + urlSearchParams.toString();
}
function compileLocalizedPathname(_ref) {
  let {
    pathname,
    locale,
    params,
    pathnames,
    query
  } = _ref;
  function getNamedPath(value) {
    let namedPath = pathnames[value];
    if (!namedPath) {
      namedPath = value;
    }
    return namedPath;
  }
  function compilePath(namedPath) {
    const template = typeof namedPath === 'string' ? namedPath : namedPath[locale];
    let compiled = template;
    if (params) {
      Object.entries(params).forEach(_ref2 => {
        let [key, value] = _ref2;
        if (Array.isArray(value)) {
          compiled = compiled.replace(new RegExp("(\\[)?\\[...".concat(key, "\\](\\])?"), 'g'), value.map(v => String(v)).join('/'));
        } else {
          compiled = compiled.replace("[".concat(key, "]"), String(value));
        }
      });
    }
    if (compiled.includes('[')) {
      // Next.js throws anyway, therefore better provide a more helpful error message
      throw new Error("Insufficient params provided for localized pathname.\nTemplate: ".concat(template, "\nParams: ").concat(JSON.stringify(params)));
    }
    if (query) {
      compiled += serializeSearchParams(query);
    }
    return compiled;
  }
  if (typeof pathname === 'string') {
    const namedPath = getNamedPath(pathname);
    const compiled = compilePath(namedPath);
    return compiled;
  } else {
    const {
      pathname: href,
      ...rest
    } = pathname;
    const namedPath = getNamedPath(href);
    const compiled = compilePath(namedPath);
    const result = {
      ...rest,
      pathname: compiled
    };
    return result;
  }
}
function getRoute(_ref3) {
  var _Object$entries$find;
  let {
    locale,
    pathname,
    pathnames
  } = _ref3;
  const unlocalizedPathname = utils.unlocalizePathname(
  // Potentially handle foreign symbols
  decodeURI(pathname), locale);
  let template = (_Object$entries$find = Object.entries(pathnames).find(_ref4 => {
    let [, routePath] = _ref4;
    const routePathname = typeof routePath !== 'string' ? routePath[locale] : routePath;
    return utils.matchesPathname(routePathname, unlocalizedPathname);
  })) === null || _Object$entries$find === void 0 ? void 0 : _Object$entries$find[0];
  if (!template) {
    template = pathname;
  }
  return template;
}
function getBasePath(pathname) {
  let windowPathname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.pathname;
  if (pathname === '/') {
    return windowPathname;
  } else {
    return windowPathname.replace(pathname, '');
  }
}

exports.compileLocalizedPathname = compileLocalizedPathname;
exports.getBasePath = getBasePath;
exports.getRoute = getRoute;
exports.normalizeNameOrNameWithParams = normalizeNameOrNameWithParams;
exports.serializeSearchParams = serializeSearchParams;
